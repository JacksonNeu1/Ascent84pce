

draw_mg:
	ld hl,(draw_buffer)
	ld (dfgs_vram_top_1),hl
	ld (dfgs_vram_top_2),hl
	ld bc,160*239
	add hl,bc
	ld (dfgs_vram_bottom_1),hl 
	ld (dfgs_vram_bottom_2),hl 
	ld (dfgs_vram_bottom_3),hl 
	ld (dfgs_vram_bottom_4),hl 
	
	ld hl,(cam_pos)
	srl h
	rr l;div by 2
	ld bc,239
	add hl,bc 
	ld a,l ;lsb cam pos 
	ld (dfgs_cam_height_1),a
	ld (dfgs_cam_height_2),a
	ld (dfgs_cam_height_3),a
	
	ld bc,0
	ld c,h;msb ccam pos 
	inc c 
	ld hl,MG_Data_frame_table
	add hl,bc
	add hl,bc 
	add hl,bc 	
	ld hl,(hl);upper frame 
	
	call draw_fg_sprites
	ret


draw_fg:
	ld hl,(draw_buffer)
	ld (dfgs_vram_top_1),hl
	ld (dfgs_vram_top_2),hl
	ld bc,160*239
	add hl,bc
	ld (dfgs_vram_bottom_1),hl 
	ld (dfgs_vram_bottom_2),hl 
	ld (dfgs_vram_bottom_3),hl 
	ld (dfgs_vram_bottom_4),hl 
	
	ld hl,(cam_pos)
	ld bc,239
	add hl,bc 
	ld a,l ;lsb cam pos 
	ld (dfgs_cam_height_1),a
	ld (dfgs_cam_height_2),a
	ld (dfgs_cam_height_3),a
	
	ld bc,0
	ld c,h;msb ccam pos 
	inc c 
	ld hl,FG_Data_frame_table
	add hl,bc
	add hl,bc 
	add hl,bc 	
	ld hl,(hl);upper frame 
	
	call draw_fg_sprites
	ret




;hl = upper frame data
 
;load cam height 123,vram top 12 vram bottom 1234
draw_fg_sprites:
	;UPPER FRAME, bottom of upper frame is not on screen, bottom of mid frame is on screen bottom of lower is not on screen
	ld de,(hl)
	ld (dfgs_sprite_pointers_1),de
	
	ld de,0
	inc hl 
	inc hl
	inc hl;past data table 
	;hl is number of elements
	ex af,af' ;'
	ld a,(hl);number of elements
	ex af,af' ;'
	inc hl 
	
	
dfgs_upper_loop:
	ld a,(hl);sprite y value 
	inc hl 
	sub (hl);subtract height
	jp nc,dfgs_upper_skip;if no carry,skip
	
dfgs_cam_height_1 .equ $ + 1
	sub 0 ;subtract camera height lsb 
	jp c,dfgs_upper_cont
	jp z,dfgs_upper_cont 
dfgs_upper_skip:
	inc hl 
	inc hl
	inc hl;to y 
	ex af,af';'
	dec a 
	jp z,dfgs_mid_start 
	ex af,af';'
	jp dfgs_upper_loop
	
dfgs_upper_cont:
	
	add a,(hl);add height
	;a now holds 0 indexed row, number of lines to skip drawing
	exx
dfgs_vram_top_1 .equ $ + 1 
	ld de,0;load top of vram 
	exx;out shadow
	
	call dfgs_setup_draw;toshadow	
	
	bit 0,l 
	jp z,dfgs_upper_fast
	call draw_slow_sprite_top_cut
	jp dfgs_upper_skip_2
dfgs_upper_fast:
	call draw_fast_sprite_top_cut
dfgs_upper_skip_2:
	exx ;out of shadow, hl holds index
	
	ld de,0 
	ld bc,0
	inc hl;to y 
	ex af,af';'
	dec a 
	jp z,dfgs_mid_start 
	ex af,af';'
	jp dfgs_upper_loop
	
dfgs_mid_start:;MIDDLE FRAME, can be top cut, no cut, or bottom cut ===============================================
	
	ld de,(hl)
	ld (dfgs_sprite_pointers_1),de
	ld de,0
	inc hl 
	inc hl
	inc hl;past data table 
	ex af,af' ;'
	ld a,(hl);number of elements
	ex af,af' ;'
	inc hl 
dfgs_mid_loop:
	ld a,(hl);y val 
	inc hl ;to height
dfgs_cam_height_2 .equ $ + 1
	sub 0;subtract cam pos
	jp c,dfgs_mid_sprite_below ;sprite is below camera pos, either full or bottom cut 
	jp z,dfgs_mid_sprite_below 
	;sprite start is above camera pos, top cut 
	cp (hl);a holds numb lines below sprite y , compare to height
	jp c,dfgs_mid_above_cont
	jp z,dfgs_mid_above_cont
dfgs_mid_skip:;sprite is entirely above or below cam pos 
	inc hl 
	inc hl
	inc hl;to y 
	ex af,af';'
	dec a 
	jp z,dfgs_lower_start 
	ex af,af';'
	jp dfgs_mid_loop
	
dfgs_mid_above_cont:
	;a = lines to skip 
	exx
dfgs_vram_top_2 .equ $ + 1 
	ld de,0
	exx
	
	call dfgs_setup_draw;toshadow
	
	bit 0,l 
	jp z,dfgs_mid_top_fast
	call draw_slow_sprite_top_cut
	jp dfgs_mid_top_slow
dfgs_mid_top_fast:
	call draw_fast_sprite_top_cut
dfgs_mid_top_slow:
	exx;out shadwo
	ld de,0 
	ld bc,0
	inc hl;to y 
	ex af,af';'
	dec a 
	jp z,dfgs_lower_start 
	ex af,af';'
	jp dfgs_mid_loop

dfgs_mid_sprite_below:;sprite start is = or below top of screen 
	;can be full or bottom cut
	;a holds distance of sprite below top of screen
	;0 = top of screen 255 = 1 below ,254 = 2 below ... 17 = bottom of screen
	dec a 
	sub 16;a holds dist from bottom
	jp c,dfgs_mid_skip
	cp (hl);compare to height
	jp c,dfgs_mid_bottom_cut
	
	;full sprite
	exx
dfgs_vram_bottom_2 .equ $ + 1
	ld de,0
	exx
	call dfgs_setup_draw;toshadow
	bit 0,l
	jp z,dfgs_mid_full_fast
	call draw_slow_sprite_full
	jp dfgs_mid_full_slow
dfgs_mid_full_fast:
	call draw_fast_sprite_full
dfgs_mid_full_slow:
	exx
	ld de,0 
	ld bc,0
	inc hl;to y 
	ex af,af';'
	dec a 
	jp z,dfgs_lower_start 
	ex af,af';'
	jp dfgs_mid_loop
	
	
dfgs_mid_bottom_cut:
	exx
dfgs_vram_bottom_1 .equ $ + 1
	ld de,0
	exx
	call dfgs_setup_draw
	inc a;for bottom cuts
	bit 0,l 
	jp z,dfgs_mid_bottom_fast
	call draw_slow_sprite_bottom_cut
	jp dfgs_mid_bottom_slow
dfgs_mid_bottom_fast:
	call draw_fast_sprite_bottom_cut
dfgs_mid_bottom_slow:
	exx
	ld de,0 
	ld bc,0
	inc hl;to y 
	ex af,af';'
	dec a 
	jp z,dfgs_lower_start 
	ex af,af';'
	jp dfgs_mid_loop
	
	
	
;BOTTOM FRAME, FULL OR BOTTOM CUT===========================================================================	
dfgs_lower_start:
	
	ld de,(hl)
	ld (dfgs_sprite_pointers_1),de
	ld de,0
	inc hl 
	inc hl
	inc hl;past data table 
	
	ex af,af' ;'
	ld a,(hl);number of elements
	ex af,af' ;'
	inc hl
	
	ld a,239
dfgs_cam_height_3 .equ $ + 1 
	sub 0;cam pos 
	ret c;if bottom frame is offscreen 
	ret z 
	;a holds distance of top line of lower frame from bottom of screen starting from 1
	ld (dfgs_lower_frame_height),a

dfgs_lower_loop:
	ld a,(hl);y
	inc hl
dfgs_lower_frame_height .equ $ + 1
	add a,0;add frame height 
	jp c,dfgs_lower_cont;sprite onscreen
dfgs_lower_skip:;sprite offscreen
	inc hl
	inc hl
	inc hl;to y 
	ex af,af';'
	dec a 
	ret z
	ex af,af';'
	jp dfgs_lower_loop
	
dfgs_lower_cont:
	;a holds sprite dist from bottom of screen, from 0
	cp (hl);compare to height
	jp c,dfgs_lower_bottom_cut
	
	;full sprite 
	exx
dfgs_vram_bottom_3 .equ $ + 1
	ld de,0
	exx
	call dfgs_setup_draw
	bit 0,l
	jp z,dfgs_lower_full_fast
	call draw_slow_sprite_full
	jp dfgs_lower_full_slow
dfgs_lower_full_fast:
	call draw_fast_sprite_full
dfgs_lower_full_slow:
	exx
	ld de,0 
	ld bc,0
	inc hl;to y 
	ex af,af';'
	dec a 
	ret z
	ex af,af';'
	jp dfgs_lower_loop
	
	
dfgs_lower_bottom_cut:
	exx
dfgs_vram_bottom_4 .equ $ + 1
	ld de,0
	exx
	call dfgs_setup_draw
	inc a;for bottom cuts
	bit 0,l 
	jp z,dfgs_lower_bottom_fast
	call draw_slow_sprite_bottom_cut
	jp dfgs_lower_bottom_slow
dfgs_lower_bottom_fast:
	call draw_fast_sprite_bottom_cut
dfgs_lower_bottom_slow:
	exx
	ld de,0 
	ld bc,0
	inc hl;to y 
	ex af,af';'
	dec a 
	ret z
	ex af,af';'
	jp dfgs_lower_loop
	
	
	
	
	
	
	
	
	
;a holds distance from bottom of screen, starting from 0, or for top cut dist above screen = num lines to skip 
;(hl) = height 	
;de = initial vram, top for top cut, otherwise bottom
;returns hl = sprite data, de = vram position
dfgs_setup_draw:
	inc hl
	ld bc,0
	ld c,(hl); x pos
	inc hl;to index
	push hl
	push bc
	exx;toshadow
	pop bc
	ld h,160
	ld l,a
	mlt hl;subtract from vram
	scf 
	ccf
	ex de,hl;hl holds vram
	sbc hl,de ;subtract to get sprite draw start line 
	add hl,bc;add x pos ;hl now holds sprite draw start pos 
	ex de,hl;put in de
	pop hl;back to frame data 
	ld c,(hl);sprite index
dfgs_sprite_pointers_1 .equ $ + 1	
	ld hl,0 ;load sprite table 
	add hl,bc
	add hl,bc 
	add hl,bc;move to sprite ptr
	;call prgmpause
	ld hl,(hl);hl holds sprite data, if even = fast sprite 

	ret

	
	
	
	
	
	
	
	
	
	
	
	