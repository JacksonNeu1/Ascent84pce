

;hl = upper frame data 
;a = camera y pos lsb 
draw_fg_sprites:
	;UPPER FRAME, bottom of upper frame is not on screen, bottom of mid frame is on screen bottom of lower is not on screen
	ld de,(hl)
	ld (dfgs_sprite_pointers_1),de
	ld de,0
	inc hl 
	inc hl
	inc hl;past data table 
dfgs_upper_loop:
	ld a,(hl); sprite y value 
	inc hl 
	sub (hl);subtract height
	jp nc,dfgs_upper_skip;if no carry,skip
	
dfgs_cam_height_1 .equ $ + 1
	sub 0 ;subtract camera height lsb 
	jp c,dfgs_upper_cont
	jp z,dfgs_upper_cont 
dfgs_upper_skip:
	inc hl 
	inc hl
	ld a,(hl);index 
	inc hl;to y 
	or a
	jp nz,dfgs_upper_loop
	jp dfgs_mid_start
	
dfgs_upper_cont:
	add a,(hl);add height
	;a now holds 0 indexed row, number of lines to skip drawing
dfgs_vram_top_1 .equ $ + 1 
	ld de,0;load top of vram 
	call dfgs_setup_draw
	
	bit 0,l 
	jp z,dfgs_upper_fast
	call draw_slow_sprite_top_cut
	jp dfgs_upper_skip_2
dfgs_upper_fast:
	call draw_fast_sprite_top_cut
dfgs_upper_skip_2:
	pop hl ;index
	ld de,0 
	ld bc,0
	ld a,(hl);index 
	inc hl;to y 
	or a
	jp nz,dfgs_upper_loop
	
	
dfgs_mid_start:;MIDDLE FRAME, can be top cut, no cut, or bottom cut ===============================================
	
	ld de,(hl)
	ld (dfgs_sprite_pointers_1),de
	ld de,0
	inc hl 
	inc hl
	inc hl;past data table 
dfgs_mid_loop:
	ld a,(hl);y val 
	inc hl ;to height
dfgs_cam_height_2 .equ $ + 1
	sub 0;subtract cam pos
	jp c,dfgs_mid_sprite_below ;sprite is below camera pos, either full or bottom cut 
	jp z,dfgs_mid_sprite_below 
	;sprite start is above camera pos, top cut 
	cp (hl);a holds numb lines below sprite y , compare to height
	jp c,dfgs_mid_above_cont
	jp z,dfgs_mid_above_cont
dfgs_mid_skip:;sprite is entirely above cam pos 
	inc hl 
	inc hl
	ld a,(hl);index 
	inc hl;to y 
	or a
	jp nz,dfgs_mid_loop
	jp dfgs_lower_start
	
dfgs_mid_above_cont:
	;a = lines to skip 
dfgs_vram_top_2 .equ $ + 1 
	ld de,0
	call dfgs_setup_draw
	
	bit 0,l 
	jp z,dfgs_mid_top_fast
	call draw_slow_sprite_top_cut
	jp dfgs_mid_top_slow
dfgs_mid_top_fast:
	call draw_fast_sprite_top_cut
dfgs_mid_top_slow:
	pop hl ;index
	ld de,0 
	ld bc,0
	ld a,(hl);index 
	inc hl;to y 
	or a
	jp nz,dfgs_mid_loop
	jp dfgs_lower_start

dfgs_mid_sprite_below:;sprite start is = or below top of screen 
	;can be full or bottom cut
	;a holds distance of sprite below top of screen
	;0 = top of screen 255 = 1 below ,254 = 2 below ... 97 = bottom of screen

	sub 97;a holds dist from bottom
	cp (hl);compare to height
	jp c,dfgs_mid_bottom_cut
	
	;full sprite
dfgs_vram_bottom_2 .equ $ + 1
	ld de,0
	call dfgs_setup_draw
	bit 0,l
	jp z,dfgs_mid_full_fast
	call draw_slow_sprite_full
	jp dfgs_mid_full_slow
dfgs_mid_full_fast:
	call draw_fast_sprite_full
dfgs_mid_full_slow:
	pop hl ;index
	ld de,0 
	ld bc,0
	ld a,(hl)
	inc hl 
	or a 
	jp nz,dfgs_mid_loop
	jp dfgs_lower_start
	
	
dfgs_mid_bottom_cut:
dfgs_vram_bottom_1 .equ $ + 1
	ld de,0
	call dfgs_setup_draw
	inc a;for bottom cuts
	bit 0,l 
	jp z,dfgs_mid_bottom_fast
	call draw_slow_sprite_bottom_cut
	jp dfgs_mid_bottom_slow
dfgs_mid_bottom_fast:
	call draw_fast_sprite_bottom_cut
dfgs_mid_bottom_slow:
	pop hl ;index
	ld de,0 
	ld bc,0
	ld a,(hl)
	inc hl 
	or a 
	jp nz,dfgs_mid_loop
	
	
	
;BOTTOM FRAME, FULL OR BOTTOM CUT===========================================================================	
dfgs_lower_start:
	ld de,(hl)
	ld (dfgs_sprite_pointers_1),de
	ld de,0
	inc hl 
	inc hl
	inc hl;past data table 

	
	ld a,159
dfgs_cam_height_3 .equ $ + 1 
	sub 0;cam pos 
	;a holds distance of top line of lower frame from bottom of screen starting from 1
	ret c;if bottom frame is offscreen 
	ret z 
dfgs_lower_loop:
	ld a,(hl);y
	inc hl
dfgs_lower_frame_height .equ $ + 1
	add a,0;add frame height 
	jp c,dfgs_lower_cont;sprite onscreen
dfgs_lower_skip:;sprite offscreen
	inc hl
	inc hl
	ld a,(hl)
	inc hl 
	or a 
	jp nz,dfgs_lower_loop
	ret
	
dfgs_lower_cont:
	;a holds sprite dist from bottom of screen, from 0
	cp (hl);compare to height
	jp c,dfgs_lower_bottom_cut
	
	;full sprite 
dfgs_vram_bottom_3 .equ $ + 1
	ld de,0
	call dfgs_setup_draw
	bit 0,l
	jp z,dfgs_lower_full_fast
	call draw_slow_sprite_full
	jp dfgs_lower_full_slow
dfgs_lower_full_fast:
	call draw_fast_sprite_full
dfgs_lower_full_slow:
	pop hl ;index
	ld de,0 
	ld bc,0
	ld a,(hl)
	inc hl 
	or a 
	jp nz,dfgs_lower_loop
	ret
	
	
dfgs_lower_bottom_cut:
dfgs_vram_bottom_4 .equ $ + 1
	ld de,0
	call dfgs_setup_draw
	inc a;for bottom cuts
	bit 0,l 
	jp z,dfgs_lower_bottom_fast
	call draw_slow_sprite_bottom_cut
	jp dfgs_lower_bottom_slow
dfgs_lower_bottom_fast:
	call draw_fast_sprite_bottom_cut
dfgs_lower_bottom_slow:
	pop hl ;index
	ld de,0 
	ld bc,0
	ld a,(hl)
	inc hl 
	or a 
	jp nz,dfgs_lower_loop
	
	ret
	
	
	
	
	
	
	
	
	
;a holds distance from bottom of screen, starting from 0, or for top cut dist above screen = num lines to skip 
;(hl) = height 	
;de = initial vram, top for top cut, otherwise bottom
;returns hl = sprite data, de = vram position
dfgs_setup_draw:
	inc hl 
	ld c,(hl); x pos
	inc hl;to index
	push hl 
	ld h,160
	ld l,a
	mlt hl;subtract from vram
	scf 
	ccf
	sbc hl,de ;subtract to get sprite draw start line 
	add hl,bc;add x pos ;hl now holds sprite draw start pos 
	ex de,hl;put in de
	pop hl;back to frame data 
	push hl
	ld c,(hl);sprite index 
dfgs_sprite_pointers_1 .equ $ + 1	
	ld hl,0;load sprite table 
	add hl,bc
	add hl,bc 
	add hl,bc;move to sprite ptr 
	ld hl,(hl);hl holds sprite data, if even = fast sprite 
	ret

	
	
	
	
	
	
	
	
	
	
	
	