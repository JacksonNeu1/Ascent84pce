
FGMaxSpriteHeight .equ 120

draw_mg:
		ld hl,(draw_buffer)
	ld (dfgs_vram_top_1),hl
	ld (dfgs_vram_top_2),hl
	ld bc,160*240
	add hl,bc
	ld (dfgs_vram_bottom_1),hl 
	ld (dfgs_vram_bottom_2),hl 
	ld (dfgs_vram_bottom_3),hl 
	ld (dfgs_vram_bottom_4),hl 
	
	ld hl,(cam_pos)
	srl h ;div by 2
	rr l 
	
	ld bc,239
	add hl,bc ;y-value of uppermost visible line of fg layer
	ld a,l ;lsb cam pos, = line number in middle frame
	ld (dfgs_cam_height_1),a
	ld (dfgs_cam_height_2),a ;y value in dataframe of uppermost line of viewport
	ld (dfgs_cam_height_3),a
		
	neg 
	ld (dfgs_viewport_to_upper_frame),a
	
	ld bc,0
	ld c,h;msb ccam pos 
	inc c 
	;ld hl,FG_Data_frame_table
	add hl,bc
	add hl,bc 
	add hl,bc 	
	ld hl,(hl);upper frame 
	
	call draw_fg_sprites
	ret



draw_fg:
	ld hl,(draw_buffer)
	ld (dfgs_vram_top_1),hl
	ld (dfgs_vram_top_2),hl
	ld bc,160*240
	add hl,bc
	ld (dfgs_vram_bottom_1),hl 
	ld (dfgs_vram_bottom_2),hl 
	ld (dfgs_vram_bottom_3),hl 
	ld (dfgs_vram_bottom_4),hl 
	
	ld hl,(cam_pos)
	ld bc,239
	add hl,bc ;y-value of uppermost visible line of fg layer
	ld a,l ;lsb cam pos, = line number in middle frame
	ld (dfgs_cam_height_1),a
	ld (dfgs_cam_height_2),a ;y value in dataframe of uppermost line of viewport
	ld (dfgs_cam_height_3),a
		
	neg 
	ld (dfgs_viewport_to_upper_frame),a ; 1 = vp bound is on frame separator
	
	ld bc,0
	ld c,h;msb ccam pos 
	inc c 
	ld hl,FG_Data_frame_table
	add hl,bc
	add hl,bc 
	add hl,bc 	
	ld hl,(hl);upper frame 
	
	call draw_fg_sprites
	ret




;hl = upper frame data
 
;load cam height 123,vram top 12 vram bottom 1234
draw_fg_sprites:
	;UPPER FRAME, bottom of upper frame is not on screen, bottom of mid frame is on screen bottom of lower is not on screen
	ld de,(hl)
	ld (dfgs_sprite_pointers_1),de ;write sprite table ptr to required locations 
	
	ld de,0
	inc hl 
	inc hl
	inc hl;past data table 
	;hl is number of elements
	
	;TODO if cam height is far below upper frame, can skip upper frame 
	
dfgs_cam_height_1 .equ $ + 1
	ld a,0 
	cp FGMaxSpriteHeight
	jp nc, dfgs_do_upper_loop
	;cam too low for upper frame sprites to be drawn
	ld bc,0
	ld c,(hl) ;bc holds number of elements
	add hl,bc 
	add hl,bc 
	add hl,bc 
	add hl,bc;hl points to end of current frame data 
	inc hl;start of next frame
	jp dfgs_mid_start ;skip upper loop
	
	
dfgs_do_upper_loop:	
	ex af,af' ;'
	ld a,(hl);number of elements
	inc a
	ex af,af' ;'
	inc hl;hl points to first sprite in upper frame  

dfgs_upper_loop:;Want to check for sprites in upper frame that extend to lower frame 

	ex af,af';'
	dec a 
	jp z,dfgs_mid_start 
	ex af,af';'

	ld a,(hl);sprite y value 
	inc hl ;to height
	
dfgs_viewport_to_upper_frame .equ $ + 1
	add a,0 ;a now holds number of lines to skip in current sprite (1 indexed)
	jp c, dfgs_upper_skip ;if sprite has large y pos, can carry over
	cp (hl) ;compare to sprite height 
	jp nc, dfgs_upper_skip
	;a now holds number of lines to skip drawing

dfgs_vram_top_1 .equ $ + 1 
	ld de,0;load top of vram 
	push hl ;save height ptr
	call dfgs_setup_draw;hl = sprite ptr, de = vram addr
	
	bit 0,l ;location of sprite data in vram indicates fast or slow sprite
	jp z,dfgs_upper_fast
	call draw_slow_sprite_top_cut
	jp dfgs_upper_skip_2
dfgs_upper_fast:
	call draw_fast_sprite_top_cut
dfgs_upper_skip_2:
	pop hl ;hl holds (height)
	

dfgs_upper_skip:
	inc hl ;to x
	inc hl ;to index 
	inc hl;to y 
	jp dfgs_upper_loop
	
	
dfgs_mid_start:;MIDDLE FRAME, can be top cut, no cut, or bottom cut ===============================================
	
	ld de,(hl) ;load sprite table ptr 
	ld (dfgs_sprite_pointers_1),de
	ld de,0
	inc hl 
	inc hl
	inc hl;past sprite table ptr
	ex af,af' ;'
	ld a,(hl);number of elements
	inc a 
	ex af,af' ;'
	inc hl ;to first y val 
dfgs_mid_loop:
	
	ex af,af';'
	dec a 
	jp z,dfgs_lower_start ;check for end of data
	ex af,af';'

	ld a,(hl);y val of sprite in dataframe
	inc hl ;to height
dfgs_cam_height_2 .equ $ + 1 ;y value in dataframe of uppermost line of viewport
	sub 0;subtract cam pos
	jp z, dfgs_mid_sprite_topline ;check case where sprite is on top line of viewport
	jp nc, dfgs_mid_sprite_above ; carried, sprite is above viewport boundary, a holds num lines to skip
dfgs_mid_sprite_topline:
	;Sprite is below viewport bound, either full or bottom cut 
	neg ;a holds number of lines sprite is below top of viewport 

	;need to check if sprite is partially or entirely below veiwport
	
	sub 240
	jp nc, dfgs_mid_skip ;sprite is entirely below viewport 
	;otherwise, a holds -lines to draw 
	neg ;a holds lines to draw 
	cp (hl) ;compare to sprite height 
	jp c, dfgs_mid_bottom_cut ;height > lines to draw, bottom is cut off 
	;otherwise, draw full sprite 
	
dfgs_vram_bottom_1 .equ $ + 1  ;FULL SPRITE, a = lines above bottom of viewport
	ld de,0;load bottom of vram 
	push hl ;save height ptr
	call dfgs_setup_draw;hl = sprite ptr, de = vram addr
	
	bit 0,l ;location of sprite data in vram indicates fast or slow sprite
	jp z,dfgs_mid_full_fast
	call draw_slow_sprite_full
	jp dfgs_mid_skip_1
dfgs_mid_full_fast:
	call draw_fast_sprite_full
dfgs_mid_skip_1:
	pop hl ;hl holds (height)
	
dfgs_mid_skip:;sprite is entirely above or below cam pos 
	inc hl ;x
	inc hl ;index 
	inc hl;to y 
	
	jp dfgs_mid_loop
	

dfgs_mid_bottom_cut:
dfgs_vram_bottom_2 .equ $ + 1  ;FULL SPRITE, a = lines above bottom of viewport
	ld de,0;load bottom of vram 
	push hl ;save height ptr
	call dfgs_setup_draw;hl = sprite ptr, de = vram addr
	
	bit 0,l ;location of sprite data in vram indicates fast or slow sprite
	jp z,dfgs_mid_bcut_fast
	call draw_slow_sprite_bottom_cut
	jp dfgs_mid_skip_2
dfgs_mid_bcut_fast:
	call draw_fast_sprite_bottom_cut
dfgs_mid_skip_2:
	pop hl ;hl holds (height)
	jp dfgs_mid_skip

dfgs_mid_sprite_above:
	;a holds lines to skip 
	cp (hl) ;compare to height
	jp nc, dfgs_mid_skip ;skip sprite, entirely above viewport

dfgs_vram_top_2 .equ $ + 1
	ld de,0;top of vram 
	push hl ;save height ptr
	call dfgs_setup_draw;hl = sprite ptr, de = vram addr
	
	bit 0,l ;location of sprite data in vram indicates fast or slow sprite
	jp z,dfgs_mid_tcut_fast
	call draw_slow_sprite_top_cut
	jp dfgs_mid_skip_3
dfgs_mid_tcut_fast:
	call draw_fast_sprite_top_cut
dfgs_mid_skip_3:
	pop hl ;hl holds (height)
	jp dfgs_mid_skip
	
	
	
;BOTTOM FRAME, FULL OR BOTTOM CUT===========================================================================	
dfgs_lower_start:
	
	ld de,(hl) ;load sprite table ptr
	ld (dfgs_sprite_pointers_1),de
	ld de,0
	inc hl 
	inc hl
	inc hl;past data table 
	
	ex af,af' ;'
	ld a,(hl);number of elements
	inc a 
	ex af,af' ;'
	inc hl
	

dfgs_cam_height_3 .equ $ + 1 
	ld a, 0
	sub 239
	ret nc;if bottom frame is offscreen 

	;a holds y value of viewport bottom line in lower frame 
	ld (dfgs_viewport_bottom_y),a

dfgs_lower_loop:

	ex af,af';'
	dec a 
	ret z
	ex af,af';'
	
	ld a,(hl);y
	inc hl ;inc to height
dfgs_viewport_bottom_y .equ $ + 1
	sub a,0;subtract y val of viewport bottom
	jp c,dfgs_lower_skip;sprite below screen
	
	;a holds number of lines to draw 
	cp (hl) ;compare to sprite height 
	jp c, dfgs_lower_bottom_cut ;bottom is below viewport 
	
	;draw full sprite 
dfgs_vram_bottom_3 .equ $ + 1  ;FULL SPRITE, a = lines above bottom of viewport
	ld de,0;load bottom of vram 
	push hl ;save height ptr
	call dfgs_setup_draw;hl = sprite ptr, de = vram addr
	
	bit 0,l ;location of sprite data in vram indicates fast or slow sprite
	jp z,dfgs_lower_full_fast
	call draw_slow_sprite_full
	jp dfgs_lower_skip_1
dfgs_lower_full_fast:
	call draw_fast_sprite_full
dfgs_lower_skip_1:
	pop hl ;hl holds (height)

dfgs_lower_skip:;sprite offscreen
	inc hl ;x 
	inc hl ;index 
	inc hl;to y 

	jp dfgs_lower_loop
	
dfgs_lower_bottom_cut: 
dfgs_vram_bottom_4 .equ $ + 1  ;FULL SPRITE, a = lines above bottom of viewport
	ld de,0;load bottom of vram 
	push hl ;save height ptr
	call dfgs_setup_draw;hl = sprite ptr, de = vram addr
	
	bit 0,l ;location of sprite data in vram indicates fast or slow sprite
	jp z,dfgs_lower_bcut_fast ;even= fast
	call draw_slow_sprite_bottom_cut
	jp dfgs_lower_skip_2
dfgs_lower_bcut_fast:
	call draw_fast_sprite_bottom_cut
dfgs_lower_skip_2:
	pop hl ;hl holds (height)
	jp dfgs_lower_skip
	
	
	
	
	
	
	
	
;a holds distance from bottom of screen, starting from 0, or for top cut dist above screen = num lines to skip 
;(hl) = height 	
;de = initial vram, top for top cut, otherwise bottom

;Subtracts a lines from de (initial vram pos),
;returns hl = sprite data, de = new vram position
dfgs_setup_draw:
	inc hl ;x pos 
	ld bc,0
	ld c,(hl); x pos
	inc hl;to index
	push hl;save sprite index 
	ld h,160
	ld l,a ;number of lines to subtract 
	mlt hl;subtract from vram
	scf 
	ccf
	ex de,hl;hl holds initial vram pos, de is lines to subtract  
	sbc hl,de ;subtract to get sprite draw start line 
	add hl,bc;add x pos ;hl now holds sprite draw start pos 
	ex de,hl;put in de
	pop hl;back to frame data 
	ld c,(hl);sprite index
dfgs_sprite_pointers_1 .equ $ + 1	
	ld hl,0 ;load sprite table 
	add hl,bc
	add hl,bc 
	add hl,bc;move to sprite ptr
	;call prgmpause
	ld hl,(hl);hl holds sprite data, if even = fast sprite 

	ret

	
	
	
	
	
	
	
	
	
	
	
	