

;hl = sprite data start, de = main data decompress location de' = loops/line data location
slow_sprite_decompress:

	ld a,%11010010;jp nc 
	ld (sdcomp_end_reached_flag),a;reset end reached flag
	ld a,0
	ld (sdcomp_loop_counter) ,a;reset loop counter
	
	ld a,(hl);width,in px
	push hl 
	ld hl,320
	ld bc,0
	ld c,a 
	scf 
	ccf 
	sbc hl,bc;320 - width
	ld (sdcomp_zeroes_between_lines),hl
	pop hl 
	ld b,a;width
	ex af,af' ;'
	ld a,b
	ld (sdcomp_sprite_width),a
	ex af,af' ;'

	inc hl
	ld a,(hl);height
	ld (sdcomp_lines_remaining),a;load remaining lines
	ld (de),a;height
	inc de
	push de;loop/line data start 
	exx;to shadow
	pop de ;de' is loop/line data
	exx

	inc hl;alpha data start
	push hl
	push hl
	ld h,a;height
	ld l,b;width
	mlt hl;number of pixels
	dec hl
	srl h
	rr l
	srl h
	rr l 
	srl h 
	rr l ;divide by 8
	inc hl 
	pop bc
	add hl,bc;hl holds start of color data
	;HL POINTING TO COLOR DATA

	ex de,hl
	ld bc,0
	ld c,a;height 
	add hl,bc	
	ex de,hl;de points to data write location
	
	
	
	
	
	exx;to shadow 
	pop hl;alpha data	
	;HL IS POINTING TO ALPHA DATA
	ld c,%10000000;alpha mask
	exx
	ld c,%11110000;color mask

;START OF LOOP
;add amount to get from ending pixels to first nonzero pair
sdcomp_find_gap_length:
sdcomp_loop_counter .equ $ + 1
	ld a,0;inc number of loops
	inc a 
	ld (sdcomp_loop_counter),a
	exx ;toshadow
	ld b,0;pairs found, always < 255 
sdcomp_add_1_gap_length .equ $
	nop
	ld a,0;nop
	ld (sdcomp_add_1_gap_length),a
sdcomp_find_gap_length_loop:
	
	scf 
sdcomp_end_reached_flag .equ $;check if end of sprite reached
	jp nc,sdcomp_end

	call sdcomp_get_next_alpha_pair
	;a holds alpha data 
	inc b
	or a 
	jp z,sdcomp_find_gap_length_loop
	;END OF LOOP, B HOLDS NUMBER OF 00 PAIRS  +1
		
	

	
	
	
	push af;saves leading pixel alpha data 
	ld a,b 
	exx;out of shadow 
	ld (de),a;GAP LENGTH 
	inc de 
	exx;into shadow 
	
	
;LEADING PIXELS
	pop af;alpha data after gap, 11 01 10
	exx;out of shadow
	push de 
	
	ld b,a;save for later
	bit 4,a ;check if first pixel has color 
	ld a,0
	ld d,%11111111;assuming no colors 
	jp z,sdcomp_leading_pixel_first_skip
	;has first color
	ld d,%11110000;save second pixel of bg 
	call sdcomp_get_next_color_ending_nibble
sdcomp_leading_pixel_first_skip:
	;a is either $00 or $0color1
	
	ld e,%11111111;assuming no colors
	
	bit 0,b;check second pixel alpha
	ld b,a;save for later 
	ld a,0
	jp z,sdcomp_leading_pixel_second_skip;
	;has second color 
	call sdcomp_get_next_color_leading_nibble
	;a = color2 0 
	ld e,%00001111;save first pixel of bg
	
sdcomp_leading_pixel_second_skip:
	;a is either 00 or c2 0 
	;b is either 00 or 0 c1 
	or b 
	ld b,a;final color data
	ld a,d 
	and e ;final mask data 
	
	pop de;return to pointer 
	
	ld (de),a;write mask data 
	inc de 
	ld a,b;color data 
	ld (de),a;write color data 
	inc de 
	exx;into shadow 
	
	
;CHECK FOR LDIR 
	ld b,0;pairs found 
sdcomp_ldir_loop:
	call sdcomp_get_next_alpha_pair
	inc b
	xor %11111111;flip bits
	jp z,sdcomp_ldir_loop;alpha data was 11
	;b holds pairs found+1
	xor %11111111;flip back
	;a holds first non 11 pair 
	dec b ;b holds pairs found
	jp z,sdcomp_no_ldir;no pairs found,no ldir length
	or a
	jp nz,sdcomp_ldir_write;ends not in 00, has single ending pixel
	;ends in 00,ending pixels will be 11 
	;must add 1 to next gap length, have already read first 00
	ld a,%00000100;inc b 
	ld (sdcomp_add_1_gap_length),a 
	ld a,$ff;ending pixels 11
	
	dec b;reduce length by 1, final pair is end pixels
	jp z,sdcomp_no_ldir;no ldir length,ending pixels is 11 
	;b holds ldir length 
	
;b holds ldir length, a holds ending pixels
sdcomp_ldir_write:
	push af;save ending pixels
	ld a,b
	exx 
	ld (de),a;write ldir length
	inc de 
	call sdcomp_write_ldir_data_loop
	exx ;toshadow
	pop af;return ending pixels
	jp sdcomp_write_end_pixels
sdcomp_no_ldir:;no ldir length, a holds ending pixels,00,10,01,11
	push af;save end pixels
	
	exx;out of shadow
	ld a,0
	ld (de),a 
	inc de 
	exx 
	pop af;return ending pixels


;WRITE ENDING PIXELS 

sdcomp_write_end_pixels:;a holds end pixels
	
	exx;out of shadow
	push de 
	
	ld b,a;save for later
	bit 4,a ;check if first pixel has color 
	ld a,0
	ld d,%11111111;assuming no colors 
	jp z,sdcomp_ending_pixel_first_skip
	;has first color
	ld d,%11110000;save second pixel of bg 
	call sdcomp_get_next_color_ending_nibble
sdcomp_ending_pixel_first_skip:
	;a is either $00 or $0color1
	
	ld e,%11111111;assuming no colors
	
	bit 0,b;check second pixel alpha
	ld b,a;save for later 
	ld a,0
	jp z,sdcomp_ending_pixel_second_skip;
	;has second color 
	call sdcomp_get_next_color_leading_nibble
	;a = color2 0 
	ld e,%00001111;save first pixel of bg
	
sdcomp_ending_pixel_second_skip:
	;a is either 00 or c2 0 
	;b is either 00 or 0 c1 
	or b 
	ld b,a;final color data
	ld a,d 
	and e ;final mask data 
	
	pop de;return to pointer 
	
	ld (de),a;write mask data 
	inc de 
	ld a,b;color data 
	ld (de),a;write color data 
	inc de 
	
	
	jp sdcomp_find_gap_length;BACK TO START
	
	



;hl/c is color data, de is ldir write pos, b' is ldir length, not in shadow 
sdcomp_write_ldir_data_loop:
	call sdcomp_get_next_color_ending_nibble	
	ld b,a;first pixel
	call sdcomp_get_next_color_leading_nibble
	or b
	
	
	ld (de),a;write color data
	inc de
	exx;to shadow
	dec b;ldir length counter
	exx
	jp nz,sdcomp_write_ldir_data_loop
	ret
	
	
	
;in shadow,returns a $FF,$0F,$F0,$00
sdcomp_get_next_alpha_pair:
	call sdcomp_get_next_alpha_bit
	or a 
	jp z,sdcomp_get_next_alpha_pair0
	ld a,$F0;FIRST BIT WAS 1
	jp sdcomp_get_next_alpha_pair1
sdcomp_get_next_alpha_pair0:
	ld a,0
sdcomp_get_next_alpha_pair1:
	ld (sdcomp_get_next_alpha_pair_or),a 
	
	call sdcomp_get_next_alpha_bit
	or a 
	jp z,sdcomp_get_next_alpha_pair2
	ld a,$0F;SECOND BIT WAS 1
	jp sdcomp_get_next_alpha_pair3
sdcomp_get_next_alpha_pair2:
	ld a,0;SECOND BIT WAS 0
sdcomp_get_next_alpha_pair3:	
sdcomp_get_next_alpha_pair_or .equ $ + 1
	or 0;AND WITH FIRST BIT 
	
	ret 


sdcomp_get_next_alpha_bit:
	;CHECKS IF OUTSIDE OF SPRITE,VIRTUAL 0s
	ex af,af' ;'
	or a
	jp z,sdcomp_line_end
	ex af,af' ;'

	;LOAD NEXT BIT
	ld a,(hl)
	and c 
	rrc c 
	jp nc,sdcomp_skip_alpha_inc
	inc hl
sdcomp_skip_alpha_inc:
	
	;DEC WIDTH COUNTER
	ex af,af' ;';to shadow
	dec a;dec width counter
	jp nz,sdcomp_setup_line_gap_skip
	
	;END OF LINE REACHED
	
	;AT LINE END,WRITE LOOPS/LINE DATA
	push af;
	ld a,(sdcomp_loop_counter)
	ld (de),a;write loops per line data
	inc de
	;DEC NUMBER LINES REMAINING
sdcomp_lines_remaining .equ $ + 1
	ld a,0
	dec a 
	ld (sdcomp_lines_remaining),a
	jp nz,sdcomp_set_end_flag_skip
	;end of last line reached 
	ld a,%11011010;jp c
	ld (sdcomp_end_reached_flag) , a
sdcomp_set_end_flag_skip:
	;SET UP NUMBER OF VIRTUAL ZEROES
	push hl
sdcomp_zeroes_between_lines .equ $ + 1 
	ld hl,0;320-width
	ld (sdcomp_remaining_zeroes_between_lines),hl
	pop hl
	pop af 
	
	
sdcomp_setup_line_gap_skip:
	ex af,af' ;';out of shadow
	ret;A HOLDS 0 OR NOT 0
	
	
	;IF OUTSIDE OF SPRITE,RETURN VIRTUAL 0
sdcomp_line_end:
	ex af,af' ;';out of shadow keep a' at 0 until next line start reached 
	push hl
	;DEC REMAINING ZEROES
sdcomp_remaining_zeroes_between_lines .equ $ + 1 
	ld hl,0;320 - width 
	dec hl
	ld (sdcomp_remaining_zeroes_between_lines),hl
	ld a,l
	or h
	pop hl
	jp z,sdcomp_line_gap_end;IF END OF VIRTUAL ZEROES
	ld a,0
	ret;return 0
	
sdcomp_line_gap_end:
	ex af,af' ;';to shadow
sdcomp_sprite_width .equ $ + 1
	ld a,0;ld shadow a with width
	ex af,af' ;';out of shadow
	ld a,0;ret 0
	ret
	



;not in shadow, returns a = color0000
sdcomp_get_next_color_leading_nibble:
	ld a,(hl);load color
	and c;and with mask
	rrc c ;rotate mask
	rrc c 
	rrc c 
	rrc c 
	jp nc,sdcomp_color_inc_skip2
	inc hl;a does need to be rotated
	rrca
	rrca
	rrca
	rrca
sdcomp_color_inc_skip2:
	ret


;not in shadow, returns a = 0000color
sdcomp_get_next_color_ending_nibble:
	ld a,(hl);load color
	and c;and with mask
	rrc c ;rotate mask
	rrc c 
	rrc c 
	rrc c 
	jp nc,sdcomp_color_inc_skip
	inc hl;
	ret
sdcomp_color_inc_skip:
	rrca
	rrca
	rrca
	rrca
	ret



sdcomp_end:
	ret 












































;FIND GAP LENGTH
;read bitsteam in pairs
;gap length = number of full pairs found 

;STARTING PIXEL(S);have read either 11,01,10 in bitstream
;write either both, start,or end pixel 

;LDIR
;read number of pairs of 11 in bitstream 
;if 0 move to ending pixels
;if ends in 00, last full 11 pair will be ending pixels 
;write ldir length 
;if 0 move to next step
;else write ldir data 


;ENDING PIXEL(S)
;00 if there is nothing after leading pixels 
;11 10 01 otherwise

;BACK TO GAP LENGTH





















	
	
	
	