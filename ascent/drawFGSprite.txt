

;de = vram , hl = data, a = number lines to draw
draw_fast_sprite_bottom_cut:
	dec de
	ld bc,0
	ld c,a
	push hl
	ld a,(hl);height
	add hl,bc;hl points to num loops required
	ld c,a;height
	ld a,(hl);a holds num loops
	pop hl
	inc hl
	add hl,bc;beginning of pixel data

	ld c,(hl);load alpha length
	ex de,hl;hl is vram, de is data
	jp dfgs_loop
	
;de = vram , hl = data, a = top lines to skip	
draw_fast_sprite_top_cut:
	dec de
	ld bc,0
	ld c,a
	push de
	ld de,0
	push hl
	ld e,(hl);height
	add hl,bc;hl points to num skip loops 

	ld c,(hl);c holds num skip loops
	pop hl;start of data
	add hl,de
	ld b,(hl);total number of loops
	inc hl;hl is pixel data
	pop de;back to vram
	push bc;save total and skipped loops
	ld a,c;loops to skip
	ld bc,0
	

draw_fast_sprite_top_loop:; need to follow through gap and drawn lengths to find start of drawing
	ld c,(hl);load with first gap length	
	ex de,hl;hl is vram
	add hl,bc
	ex de,hl;hl is data
	inc hl
	ld c,(hl);ldir length
	add hl,bc;add ldir length
	ex de,hl;hl is vram
	add hl,bc;add ldir length
	inc de
	ex de,hl;hl is data
	dec a
	jp nz,draw_fast_sprite_top_loop
	
	
	pop bc
	ld a,b
	sub a,c;subtract skipped from total, a holds remaining number of loops
		
	ld bc,0
	ld c,(hl)
	ex de,hl
	jp dfgs_loop


;de = vram , hl = data
draw_fast_sprite_full:
	dec de
	ld bc,0
	ld c,(hl);height
	add hl,bc
	ld a,(hl);total loops
	inc hl
	ld c,(hl);first gap length
	ex de,hl
;a = num loops, c = alphaLength,hl = vram
dfgs_loop:;gap, colors
	add hl,bc;add alpha length
	ex de,hl;swap, hl is data, de is vram
	inc hl
	ld c,(hl);get ldir length
	inc hl
	ldir
	ld c,(hl);load c with next alpha length
	ex de,hl;swap, hl is vram
	dec a
	jp nz,dfgs_loop
	ret
	
	
	
	


;hl = data, de = vram
draw_slow_sprite_full:
	ld bc,0
	ld c,(hl);height
	add hl,bc
	ld a,(hl);num loops
	exx
	ld c,a
	exx
	dec de
	;hl = (gap length) -1 de = vram-1 c' = loops
dsfgs_line_loop:
	inc hl;gap length
	ld c,(hl);gap length
	ex de,hl;hl is vram
	add hl,bc;add aplha gap
	ex de,hl;hl is data
	inc hl;hl points to single pix mask
	ld a,(de);vram data
	and (hl)
	inc hl;pixel data
	or (hl)
	ld (de),a
	inc hl;ldir length
	
	inc de;move to next pixel
	
	ld a,(hl);ldir length
	inc hl;data
	ld c,a
	or a
	jp z,dsfgs_ldir_skip
	ldir
dsfgs_ldir_skip:
	ld a,(de);vram data
	and (hl)
	inc hl;pixel data
	or (hl)
	ld (de),a
	
	exx 
	dec c
	exx
	jp nz,dsfgs_line_loop
	ret


;de = vram , hl = data, a = top lines to skip	
draw_slow_sprite_top_cut:

	push hl
	ld bc,0
	ld c,a
	add hl,bc
	ld a,(hl);loops to skip
	ld (dsstc_loops_skipped),a
	exx
	ld b,a;loops to skip
	exx
	pop hl
	ld c,(hl)
	add hl,bc;total loops
	ld a,(hl);total loops
	inc hl;gap length

;hl = data start, b' = num loops,bc = 0
	exx
slow_sprite_data_traverse:
	exx
	ld c,(hl);gap length
	ex de,hl;hl is vram
	add hl,bc
	ex de,hl
	
	inc hl
	inc hl
	inc hl;ldir length
	ld c,(hl)
	add hl,bc
	ex de,hl
	add hl,bc
	ex de,hl
	inc de;single pix
	inc hl
	inc hl
	inc hl;gap length
	exx
	djnz slow_sprite_data_traverse
	exx

dsstc_loops_skipped .equ $ + 1
	sub a,0;loops skipped
	exx
	ld c,a
	exx
	
	dec de
	dec hl	
	jp dsfgs_line_loop
	
;de = vram , hl = data, a = number lines to draw
draw_slow_sprite_bottom_cut:
	ld bc,0
	push hl
	ld c,a;height
	add hl,bc
	ld a,(hl);num loops
	exx
	ld c,a
	exx
	pop hl
	ld c,(hl)
	add hl,bc

	dec de
	jp dsfgs_line_loop



































 























































	
	